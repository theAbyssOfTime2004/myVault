[[dict, set]]

## 🎯 Kế hoạch hôm nay
- [ ] Học lý thuyết: 
- [ ] Làm bài:
  - [x] Group Anagram
  - [x] Valid Palindrome
  - [x] Intersection of two arrays

## 🕒 Thời gian thực hành
- Bắt đầu: ...
- Kết thúc: ...

## 🧠 Ghi chú nhanh
- cheatsheet:
```python
sorted("eat") # ['a', 'e', 't'] - list ký tự
"".join(sorted("eat")) # 'aet'- string mới

tuple(sorted("eat")) #hashable, dùng làm key dict

print("a".isalnum())   # True  (chữ cái)
print("Z".isalnum())   # True  (chữ cái)
print("5".isalnum())   # True  (chữ số)
print(" ".isalnum())   # False (khoảng trắng)
print(",".isalnum())   # False (dấu phẩy)
print("é".isalnum())   # True  (kí tự Unicode chữ cái)

# reverse string
"abc"[::-1]  # 'cba'

# set
set1 = set([1,2,2,1]) # tạo ra 1 tập hợp các phần tử duy nhất {1, 2}
```
### Bài 4. Group Anagrams
- Cách 1: Key -> complexity: `O(n*k)`
```python
from collections import defaultdict
def groupAnagrams(self, strs):
	groups = defaultdict(list)
	for word in strs:
		key = "".join(sorted(word))
		groups[key].append(word)
	return list(groups.values())
```
- duyệt qua mảng strs, với mỗi từ trong mảng chuẩn hóa bằng cách `join(sorted(str))` nghĩa là các từ `eat, ate, tea` sẽ là -> `aet`, tạo key = từ chuẩn hóa <=> `key = 'aet'`, sau đó duyệt tiếp mảng, với bất cứ word nào có `key = 'aet'`thì groups sẽ được append với value là chính word đó, nghĩa là sau cùng ta có 1 dictionary gồm key là từ chuẩn hóa còn value là các từ có key giống nhau (nghĩa là `key là aet` thì value gồm các `eat, ate, tea`), lặp lại như vậy với các từ còn lại, sau cùng dùng `list(groups.value())` để return dạng mảng cho phù hợp với yêu cầu đề bài
- Cách 2: Hashing bằng số nguyên tố - complexity gần `O(n*k)`
```python
from collections import defaultdict
PRIMES = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101]
def groupAnagrams(self, strs):
	groups  = defaultdict(list)
	for word in (strs):
		key = 1 
		for char in word.lower():
			if 'a' <= char <= 'z':
				key *= PRIME[ord(char) - ord('a')]
		groups[key].append(word)
	return list(groups.values())
```

- có 26 số nguyên tố ứng với 26 chữ cái từ a-z, nghĩa là các anagram <=> tích các số nguyên tố <=> duy nhất, do đó với mỗi anagram sẽ là một tích các số nguyên tố duy nhất từ đó làm tương tự như cách trên, ta cần .lower() để chuyển các chữ uppercase thành lowercase rồi mới làm . Hạn chế là có thể tràn số với chuỗi dài và float cũng có thể có sai số 

### Bài 5: Valid Palindrome (125)

```python
def isPalindrome(self, s):
	filtered = [ch.lower() for ch in s if ch.isalnum()]
	filtered_s = "".join(filtered)
	return filtered_s == filtered_s[::-1]
```
- `ch.lower() for ch in s if ch.isalnum()` nghĩa là ta sẽ lowercase toàn bộ những từ mà `ch.isalnum()` trả về `True` cho vào biến filtered, sau đó tạo chuỗi `filtered_s` bằng cách `"".join(filtered)` và `filtered == filtered[::-1]` là đang so sánh 2 chuỗi filtered_s với nhau 1 cái xuất phát từ đầu và 1 cái xuất phát từ cuối và sẽ trả về `True` nếu toàn bộ ký tự của chuỗi giống nhau và `false` nếu ngược lại
- Còn cách khác là sử dụng *2 Pointer*   

### Bài 6: Intersection of Two Arrays 
- Cách 1: dùng set
```python 
def intersection(self, nums1, nums2):
	set1 = set(nums1)
	set2 = set(nums2)
	return list(set1 & set2)
```
- Cách 2: dùng hash table như bài TwoSum
```python
def intersection(self, nums1, nums2):
	freq = {}
	result = []
	for val in nums1:
		freq[val] = True # vì freq là 1 dictionary nên không dùng append, dòng này có nghĩa là thêm 1 key val vào dict freq với value là True - nghĩa là có tồn tại 
	for val in nums2:
		if val infreq and val not in res:
			res.append(val)
	return res
```

### Bài 7: Top K frequent Elements (347

```python
def topKFrequent(self, nums, k):
	freq = {}
	for i, x in enumerate(nums)
		if x not in freq:
			freq[x] = 1
		else:
			freq[x] += 1
	freq_items = list(freq.items())
	freq_sorted = sorted(freq_items, lambda items:item[1], reverse=True) 
	res = []
	for i in range(k):
		res.append(freq_sorted[i][0])
	return res
```
- `lambda items:item[1]` nghĩa là lấy phần tử thứ 2 của tuple item, với item là mỗi tuple `(element, frequency)` trong `freq_items`, nghĩa là khi sorted nó sẽ chạy theo frequency chứ không phải theo element
- `freq_sorted[i][0]`  là để chắc chắn lấy ra element chứ không cần lấy thêm frequency vì ví dụ:
```python
nums = [1,1,1,2,2,3], k = 2
freq_sorted = [(1, 3), (2, 2), (3, 1)]
```
với `freq_sorted[i]` ta sẽ có `freq_sorted[0]` = `(1, 3)`
