

## 🎯 Kế hoạch hôm nay
- [ ] Học lý thuyết: ...
- [ ] Làm bài:
  - [ ] Group Anagram
  - [ ] Valid Palindrome
  - [ ] Intersection of two arrays

## 🕒 Thời gian thực hành
- Bắt đầu: ...
- Kết thúc: ...

## 🧠 Ghi chú nhanh
- cheatsheet:
```python
sorted("eat") # ['a', 'e', 't'] - list ký tự
"".join(sorted("eat")) # 'aet'- string mới

tuple(sorted("eat")) #hashable, dùng làm key dict
```
### Bài 4. Group Anagrams
- Cách 1: Key -> complexity: `O(n*k)`
```python
from collections import defaultdict
def groupAnagrams(self, strs):
	groups = defaultdict(list)
	for word in strs:
		key = "".join(sorted(word))
		groups[key].append(word)
	return list(groups.values())
```
- duyệt qua mảng strs, với mỗi từ trong mảng chuẩn hóa bằng cách `join(sorted(str))` nghĩa là các từ `eat, ate, tea` sẽ là -> `aet`, tạo key = từ chuẩn hóa <=> `key = 'aet'`, sau đó duyệt tiếp mảng, với bất cứ word nào có `key = 'aet'`thì groups sẽ được append với value là chính word đó, nghĩa là sau cùng ta có 1 dictionary gồm key là từ chuẩn hóa còn value là các từ có key giống nhau (nghĩa là `key là aet` thì value gồm các `eat, ate, tea`), lặp lại như vậy với các từ còn lại, sau cùng dùng `list(groups.value())` để return dạng mảng cho phù hợp với yêu cầu đề bài
- Cách 2: Hashing bằng số nguyên tố 
```python
from collections import defaultdict
PRIMES = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101]
def groupAnagrams(self, strs):
	groups  = defaultdict(list)
	for word in (strs):
	key = 1 
	for char in word.lower():
		if 'a' <= char <= 'z':
			key *= PRIME[ord(char) - ord('a')]
```