[[dict, set]]

## 🎯 Kế hoạch hôm nay
- [ ] Học lý thuyết: 
- [ ] Làm bài:
  - [x] Group Anagram
  - [x] Valid Palindrome
  - [x] Intersection of two arrays
  - [x] Top K Frequent Elements
  - [x] Ransom Note

## 🕒 Thời gian thực hành
- Bắt đầu: ...
- Kết thúc: ...

## 🧠 Ghi chú nhanh
- cheatsheet:
```python
sorted("eat") # ['a', 'e', 't'] - list ký tự
"".join(sorted("eat")) # 'aet'- string mới

tuple(sorted("eat")) #hashable, dùng làm key dict

print("a".isalnum())   # True  (chữ cái)
print("Z".isalnum())   # True  (chữ cái)
print("5".isalnum())   # True  (chữ số)
print(" ".isalnum())   # False (khoảng trắng)
print(",".isalnum())   # False (dấu phẩy)
print("é".isalnum())   # True  (kí tự Unicode chữ cái)

# reverse string
"abc"[::-1]  # 'cba'

# set
set1 = set([1,2,2,1]) # tạo ra 1 tập hợp các phần tử duy nhất {1, 2}
```
### Bài 4. Group Anagrams
- Cách 1: Key -> complexity: `O(n*k)`
```python
from collections import defaultdict
def groupAnagrams(self, strs):
	groups = defaultdict(list)
	for word in strs:
		key = "".join(sorted(word))
		groups[key].append(word)
	return list(groups.values())
```
- duyệt qua mảng strs, với mỗi từ trong mảng chuẩn hóa bằng cách `join(sorted(str))` nghĩa là các từ `eat, ate, tea` sẽ là -> `aet`, tạo key = từ chuẩn hóa <=> `key = 'aet'`, sau đó duyệt tiếp mảng, với bất cứ word nào có `key = 'aet'`thì groups sẽ được append với value là chính word đó, nghĩa là sau cùng ta có 1 dictionary gồm key là từ chuẩn hóa còn value là các từ có key giống nhau (nghĩa là `key là aet` thì value gồm các `eat, ate, tea`), lặp lại như vậy với các từ còn lại, sau cùng dùng `list(groups.value())` để return dạng mảng cho phù hợp với yêu cầu đề bài
- Cách 2: Hashing bằng số nguyên tố - complexity gần `O(n*k)`
```python
from collections import defaultdict
PRIMES = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101]
def groupAnagrams(self, strs):
	groups  = defaultdict(list)
	for word in (strs):
		key = 1 
		for char in word.lower():
			if 'a' <= char <= 'z':
				key *= PRIME[ord(char) - ord('a')]
		groups[key].append(word)
	return list(groups.values())
```

- có 26 số nguyên tố ứng với 26 chữ cái từ a-z, nghĩa là các anagram <=> tích các số nguyên tố <=> duy nhất, do đó với mỗi anagram sẽ là một tích các số nguyên tố duy nhất từ đó làm tương tự như cách trên, ta cần .lower() để chuyển các chữ uppercase thành lowercase rồi mới làm . Hạn chế là có thể tràn số với chuỗi dài và float cũng có thể có sai số 

### Bài 5: Valid Palindrome (125)

```python
def isPalindrome(self, s):
	filtered = [ch.lower() for ch in s if ch.isalnum()]
	filtered_s = "".join(filtered)
	return filtered_s == filtered_s[::-1]
```
- `ch.lower() for ch in s if ch.isalnum()` nghĩa là ta sẽ lowercase toàn bộ những từ mà `ch.isalnum()` trả về `True` cho vào biến filtered, sau đó tạo chuỗi `filtered_s` bằng cách `"".join(filtered)` và `filtered == filtered[::-1]` là đang so sánh 2 chuỗi filtered_s với nhau 1 cái xuất phát từ đầu và 1 cái xuất phát từ cuối và sẽ trả về `True` nếu toàn bộ ký tự của chuỗi giống nhau và `false` nếu ngược lại
- Còn cách khác là sử dụng *2 Pointer*   

### Bài 6: Intersection of Two Arrays 
- Cách 1: dùng set
```python 
def intersection(self, nums1, nums2):
	set1 = set(nums1)
	set2 = set(nums2)
	return list(set1 & set2)
```
- Cách 2: dùng hash table như bài TwoSum
```python
def intersection(self, nums1, nums2):
	freq = {}
	result = []
	for val in nums1:
		freq[val] = True # vì freq là 1 dictionary nên không dùng append, dòng này có nghĩa là thêm 1 key val vào dict freq với value là True - nghĩa là có tồn tại 
	for val in nums2:
		if val infreq and val not in res:
			res.append(val)
	return res
```

### Bài 7: Top K frequent Elements (347)

```python
def topKFrequent(self, nums, k):
	freq = {}
	for i, x in enumerate(nums)
		if x not in freq:
			freq[x] = 1
		else:
			freq[x] += 1
	freq_items = list(freq.items())
	freq_sorted = sorted(freq_items, lambda items:item[1], reverse=True) 
	res = []
	for i in range(k):
		res.append(freq_sorted[i][0])
	return res
```
- `lambda items:item[1]` nghĩa là lấy phần tử thứ 2 của tuple item, với item là mỗi tuple `(element, frequency)` trong `freq_items`, nghĩa là khi sorted nó sẽ chạy theo frequency chứ không phải theo element
- `freq_sorted[i][0]`  là để chắc chắn lấy ra element chứ không cần lấy thêm frequency vì ví dụ:
```python
nums = [1,1,1,2,2,3], k = 2
freq_sorted = [(1, 3), (2, 2), (3, 1)]
```
với `freq_sorted[i]` ta sẽ có `freq_sorted[0]` = `(1, 3)`, `freq_sorted[1]` = `(2, 2)`...and so on
nếu ta muốn res trả về chỉ là 1 số duy nhất như đề bài, thì ta phải ghi `freq_sorted[i][...]` với `[...]` phải là 1 số nào  đó, và tuple chỉ có 2 phần tử (element, frequency) <=> chỉ index 0 và 1 là hợp lệ và nếu là index 1 thì là frequency <=> không cần thiết nên ta cần sử dụng index 0 do đó => `freq_sorted[i][0]`

### Bài 8: Ransom Note (383)
-  Cách dùng dict và duyệt mảng:
```python
	def canConstruct (self, ransomNote, magazine):
		freq = {}
		for char in magazine:
			freq[char] = freq.get(char, 0) + 1
		for char in ransomNote:
			if freq.get(char, 0) == 0:
				return False
			freq[char] -= 1
		return True
```

- ban đầu tạo dict rỗng freq sau đó duyệt từng ký tự trong magazine, với mỗi ký tự kiểm tra xem có tồn tại trong `freq {}` chưa. nếu chưa thì + 1 để đếm số lần xuất hiện, khi lặp hết `magazine` thì ta có số lần xuất hiện của các ký tự trong `magazine`, sau đó duyệt đến `ransomNote`, với mỗi ký tự của `ransomNote`, nếu có xuất hiện trong freq thì ta sẽ trừ số lần xuất hiện đi 1 để đánh dấu là ta đã vừa dùng số đó 1 lần, còn nếu không xuất hiện thì ta `return False` luôn bởi vì chắc chắn `ransomNote` sẽ khác `magazine`, và ta chỉ `return True` khi mà duyệt hết toàn bộ `ransomNote` mà không bị return False trước đó, nghĩa là không có ký tự nào không trùng giữa 2 mảng