## 🎯 Kế hoạch hôm nay
- [x] Học lý thuyết: `list, string, stack, pointer`
- [x] Làm bài:
  - [x] Encode and decode strings
  - [ ] Valid Parentheses
  - [ ] Majority Elements

## 🕒 Thời gian thực hành
- Bắt đầu: ...
- Kết thúc: ...

## 🧠 Ghi chú nhanh
- Cheatsheet: 
```python
# join list thành chuỗi
words = ["hello", "world"]
result = "|".join(words) # "hello|world"

# Split chuỗi thành list
s = "hello|world"
parts = s.split("|") # ['hello', 'world']

# slice chuỗi
s = "abcdef"
print(s[2:5]) #cde" (lấy s[2], s[3], s[4]), lưu ý: s[i:j] lấy ký tự i -> j nhưng không bao gồm ký tự tại j   
# lowercase, uppercase
text = "Hello"
text.lower()
text.upper()

# Reverse chuỗi
s = "abc"
s[::-1] # "cba"

# Sort ký tự trong chuỗi -> list 
chars = sorted("cba") # ['a', 'b', 'c']

# Convert list ký tự thành chuỗi
"".join(chars) # abc

# stack với list
stack = [] # khởi tạo stack rỗng 
stack.append(19) #push
stack.append(20)
top = stack.pop() # pop & trả về phần tử cuối 
```


### Bài 9: Encode and Decode Strings
- naive approach, khi encode, sử dụng 1 non-ascii char để làm delimiter giữa các chuỗi, sau dó `.join` các chuỗi con thành 1 chuỗi to và khi decode, sử dụng .`split` để tách chuỗi to thành list các chuỗi con dựa trên delimiter đó. Cách này sẽ hoạt động tốt nếu ta đảm bảo đươc rằng non-ascii delimiter đó 100% sẽ không xuất hiện trong các chuỗi con, và cũng có thể không xử lý được chính xác trong trường hợp có chuỗi rỗng. 
```python
def encode(self, strs: List[str]) -> str:
	result = "§".join(strs)
return result

def decode(self, s: str) -> List[str]:
	result = s.split("§")
return result
```
- `prefix-length` approach
```python
def encode(self, strs: List[str]) -> str:
	return ', '.join(f"{len(s)}#{s}) for s in strs

def decode(self,s: str) -> List[str]:
	res = []
	i = 0
	while i < len(s):
		j = s.find('#', i)
		length = int(s[i:j])
		string = s[j+1 : j+1+length]
		res.append(string)
		i = j + 1 + length
		if i < len(s) and s[i:i+2] == ", ":
			i += 2
	return res
```

- giải thích hàm `encode`: sử dụng literal f string để in thẳng vào chuỗi trong list strs dạng `<len>#<string>`, ví dụ ta có chuỗi `["hello", "world"]` thì `f"{len(s)}#{s}` sẽ trả về list `["5#hello", "5#world"]` sau đó dùng `', '.join()` và ta được chuỗi như sau: `5#hello, 5#world` 
- giải thích hàm `decode`: tạo list res rỗng chứa kết quả và index i = 0, lặp qua `chuỗi s`, sử dụng `s.find('#', i)` để tìm vị trí xuất hiện `#` tính từ `i` và vị trí này sẽ là `index của j`, độ dài (`length`) của chuỗi sẽ được lấy bằng cách sử dụng `int(s[i:j])` chính là cắt nội dung trong chuỗi s `từ vị trí i đến vị trí j (không bao gồm j)`, và lấy số nguyên, sau đó `s[j+1 : j+1+length]` sẽ trả về nội dung, và string được append vào list res, ta phải cập nhật i nếu không muốn lặp vô tận, ngoài ra vì khi encode ta join = delimiter là `', '` nên chuỗi sẽ có phân cách bằng `', '`, bây giờ khi decode -> list ta phải loại bỏ `', '` bằng cách xét điều kiện `if i < len(s) and s[i:i+2] == ", "` nghĩa là sau khi xử lý xong 1 string, ta xét xem chỗ đang đứng  của i có chứa `', '` hay không, nếu có thì phải cộng thêm 2 cho `i` để nhảy qua vị trí đó, ta xét `i < len(s)` để tránh `indexError` khi duyệt đến cuối mảng   
- ví dụ với chuỗi `5#hello, 5#world`, duyệt qua tại ví trí đầu tiên ta sẽ được `i = 0`, `j = s.find('#', 1) = 1` vì `i` ở vị trí 0 (là số 5) và `# `ở vị trí ngay bên cạnh, sau đó có length là `5` vì `int(s[i:j]) = int(s[0:1]) int(s[0]) = int(5) = 5` , tiếp tục lấy giá trị của string, ta được `string = hello` vì lúc này `j + 1 = 2 và j + 1 + length = 7` và từ `s[2] -> trước s[7] tức s[6]` sẽ là `hello`, sau đó append `hello` vào `res`, set `i = j+1+length = 7` và xét tiếp xem vị trí đang đứng có phải `", "` hay không, vì `i hiện tại = 7  < len(s)` và `s[i: i+2] <=> s[7:9] <=> s[7] và s[8] = ", "` nên ta tăng `i` lên 2 đơn vị để bỏ đi `", "`, sau đó lặp lại như trên đến khi  hết mảng và return res