
## 🎯 Kế hoạch hôm nay
- [ ] Học lý thuyết: ...
- [ ] Làm bài:
  - [x] Valid Sudoku
  - [x] Happy Number
  - [x] Largest 3-same digit Number in string

## 🕒 Thời gian thực hành
- Bắt đầu: ...
- Kết thúc: ...

## 🧠 Ghi chú nhanh

### Bài 14. Largest 3-same Digits Number in String

```python
def largest3Digs(self, nums):
	ans = ""
	for i in range (len(nums) - 2):
		if num[i] == num[i+1] == num[i+2]:
			ans = max(ans, num[i:i+3])
	return ans
```
- Ý tưởng và cách implement khá đơn giản, xét 3 chữ số liên tục, nếu giống nhau thì cho vào `ans` lấy max để được 3 chữ số liên tiếp lớn nhất, `num[i:i+3]` để cắt mảng nums từ đoạn `i` -> `i+3` -> lấy ra 3 giá trị liên tiếp theo yêu cầu đề bài
### Bài 15. Happy Number 

```python
def sum_sq_digits(self, x): 
	s = 0
	while x > 0:
		d = x % 10
		s += d * d
		x //= 10
	return s

def isHappy(self, n):
	seen = set()
	while n!- 1 and n not in seen:
		seed.add(n)
		n = sum_sq_digits(n)
	return n == 1
```

- Ý tưởng đơn giản là ta cứ tách từng số các số hạng ra rồi sau đó tính tổng bình phương của chúng, nếu = 1 thì True, còn phát hiện lặp thì False, hàm `sum_sq_digtis` để tách từng số các số hạng ra và tính tổng bình phương, bên cạnh đó ta có thể chứng minh rằng chuỗi tổng bình phương là có chu kỳ và sẽ lặp lại chứ không phân kỳ bằng cách xét tổng bình phương của các số có số hạng >= 4 (vì với các số có số hạng >= 4, tổng bình phương của các số hạng đó sẽ luôn bé hơn chính số ban đầu `81 * d <= 999`) và sử dụng định lý `dirichlet` ta có thể chứng minh rằng sẽ có 2 số giống nhau trong khoảng `(1, 999)` lặp lại

### Bài 16. Valid sudoku
```python
def isValidSudoku(self, board):
	rows = [set() for _ in range(9)]
	cols = [set() for _ in range(9)]
	boxes = [set() for _ in range(9)]

	for i in range(9)
		for j in range(9)
			val == board[i][j]
			if val == "."
				continue
			#kiểm tra hàng
			if val in rows[i]
				return False
			rows[i].add(val)

			#kiểm tra cột
			if val in cols[i]
				return False
			cols[i].add(val)

			#kiểm tra ô 3x3
			box_index = (i // 3) * 3 + (j // 3)
			if val in boxes[box_index]
				return False
			boxes[box_index].add(val)
	Return True
```
- Ý tưởng cốt lõi là bruteforce theo 3 rule:
	- Mỗi hàng phải contain giá trị trong khoảng `1-9`
	- Mỗi cột phải contain giá trị trong khoảng `1-9`
	- mỗi ô `3x3` phải contain giá trị trong khoảng `1-9`
.
- Thử thách khó khăn nhất ở bài trên là ta phải tìm cách để kiểm tra các ô `3x3` có contain các giá trị trong khoảng `1-9` không, bằng cách lấy `i // 3` và `j // 3` ta được index của các ô 3x3, xem mỗi ô `3x3` là 1 phần tử trong mảng 2 chiều có số hàng là 3 và số cột là 3 thì việc lấy các phép chia lấy dư index của mảng `9x9` ta được index của các ô đó 
- Bảng Sudoku có **9 ô vuông 3x3** (chia bảng 9x9 thành 9 block nhỏ).  
- Để biết một ô `(i, j)` nằm ở block nào → ta dùng `i // 3` và `j // 3`:
	- `i // 3`: cho biết ô đó đang ở hàng số mấy của block.
	    - `i = 0,1,2` → `i // 3 = 0` (block hàng trên cùng)    
	    - `i = 3,4,5` → `i // 3 = 1` (block hàng giữa)
	    - `i = 6,7,8` → `i // 3 = 2` (block hàng dưới)
	- `j // 3`: cho biết ô đó đang ở cột số mấy của block.
	    - `j = 0,1,2` → `j // 3 = 0` (block cột bên trái)
	    - `j = 3,4,5` → `j // 3 = 1` (block cột giữa)
	    - `j = 6,7,8` → `j // 3 = 2` (block cột bên phải)
- Sau cùng ta flatten index của ô `3x3` để mapping từ mảng 2 chiều về mảng 1 chiều (vì set boxes ban đầu được tạo là mảng 1 chiều)