the[[linked list]], [[stack]], [[queue]]

## ğŸ¯ Káº¿ hoáº¡ch hÃ´m nay
- [ ] Há»c lÃ½ thuyáº¿t: linked list, stacked
- [ ] LÃ m bÃ i:
  - [x] Implement Stack using Queues
  - [x] Remove Outermost Parentheses
  - [x] Min Stack

## ğŸ•’ Thá»i gian thá»±c hÃ nh
- Báº¯t Ä‘áº§u: ...
- Káº¿t thÃºc: ...

## ğŸ§  Ghi chÃº nhanh
- Vá»›i **Queue** â†’  `front [1,2,3,4] rear`
- Vá»›i **Stack** â†’ `bottom [1,2,3,4] top`
Tá»©c lÃ :
- Queue nhÃ¬n tá»« trÃ¡i sang pháº£i: **láº¥y ra tá»« trÃ¡i (front)**, thÃªm vÃ o pháº£i (rear).
- Stack nhÃ¬n tá»« trÃ¡i sang pháº£i: **láº¥y ra tá»« pháº£i (top)**, thÃªm vÃ o pháº£i (top).
- cheatsheet:
```python

from collections imoport deque
q = deque()
q.append(1) # enqueue -> [1]
q.append(2) # enqueue -> [1, 2]
q[0] # front() = 1
q.popleft() # dequeue() = 1, queue cÃ²n [2]
```

### Implement Stack Using Queues

```python
class MyStack(object):
	from collections import deque
	def __init__():
		self.q = deque()
	
	def push(self, x):
		self.q.append(x)
		for _ in range(len(self.q) - 1):
				self.q.append(self.q.popleft())
	
	def pop(self):
		return self.q.popleft()
		
	def top(self):
		return self.q[0]
	
	delf empty(self):
		returrn len(self.q) == 0
```

### Remove OuterMost Parentheses

```python
def removeOuterParentheses(self, s):
	depth = 0
	res = []
	for c in s:
		if c == '(':
			if depth > 0:
				res.append(c)
			depth += 1
		else:
			depth -= 1
			if depth > 0:
				res.append(c)
	return "".join(res)
	
```
- nháº­n diá»‡n cÃ¡c bá»™ primitive VPS (valid parentheses string) = má»™t VPS khÃ´ng thá»ƒ tÃ¡ch thÃ nh hai VPS khÃ¡c nhau.
	- `"()"` â†’ primitive
	- `"(()())"` â†’ primitive
	- `"()()"` â†’ **khÃ´ng pháº£i primitive**, vÃ¬ cÃ³ thá»ƒ tÃ¡ch thÃ nh `"()" + "()"`.
- nghÄ©a lÃ  gáº·p cáº·p ngoáº·c outermost thÃ¬ bá» qua (báº±ng cÃ¡ch chá»‰ + thÃªm depth mÃ  khÃ´ng append vÃ o res), cÃ²n cÃ¡c ngoáº·c bÃªn trong thÃ¬ thÃªm vÃ o res - tÄƒng giáº£m depth thÃ¬ tÃ¹y vÃ o ngoáº·c Ä‘Ã³ng hay má»Ÿ)

### Min Stack

```python
class MinStack(object):

	def __init__(self):
		self.stack = []
		self.min_stack = []
	
	def push(self, val)
		self.stack.append(val)
		if not self.min_stack or val <= self.min_stack[-1]:
			self.min_stack.append(val)
		else:
			self.min_stack.append(self.min_stack[-1])
			
	
	def pop(self):
		self.stack.pop()
		self.min_stack.pop()
		
	def top(self):
		return self.stac[-1]
		
	def getMin(self):
		return self.min_stack[-1]

```

```python
VÃ­ dá»¥ minh há»a:

push(3) â†’ stack=[3], min_stack=[3]
push(5) â†’ stack=[3,5], min_stack=[3,3]
push(2) â†’ stack=[3,5,2], min_stack=[3,3,2]
push(1) â†’ stack=[3,5,2,1], min_stack=[3,3,2,1]

getMin() â†’ 1
pop()   â†’ stack=[3,5,2], min_stack=[3,3,2]
getMin() â†’ 2

```
